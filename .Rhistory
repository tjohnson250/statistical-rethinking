#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#remotes::install_github("stan-dev/cmdstanr")
#devtools::install_github("rmcelreath/rethinking")
# List of packages to check and install
packages_to_install <- c("coda","mvtnorm","devtools","loo","dagitty","shape")
# Loop through the packages
for (pkg in packages_to_install) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE) # Load after installation
}
}
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#remotes::install_github("stan-dev/cmdstanr")
#devtools::install_github("rmcelreath/rethinking")
# List of packages to check and install
packages_to_install <- c("coda","mvtnorm","devtools","loo","dagitty","shape")
if (!require("pak")) {
install.packages("pak")
}
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#remotes::install_github("stan-dev/cmdstanr")
#devtools::install_github("rmcelreath/rethinking")
# List of packages to check and install
packages_to_install <- c("coda","mvtnorm","devtools","loo","dagitty","shape")
# pak checks to see if a library is installed and if not installs it from either CRAN
# or GitHub depending on its specification
if (!require("pak")) {
install.packages("pak")
}
pak::pkg_install(c(
"coda","mvtnorm","devtools","loo","dagitty","shape",
"stan-dev.cmdstanr",
"rmcelreath/rethinking"
))
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#remotes::install_github("stan-dev/cmdstanr")
#devtools::install_github("rmcelreath/rethinking")
# List of packages to check and install
packages_to_install <- c("coda","mvtnorm","devtools","loo","dagitty","shape")
# pak checks to see if a library is installed and if not installs it from either CRAN
# or GitHub depending on its specification
if (!require("pak")) {
install.packages("pak")
}
pak::pkg_install(c(
"coda","mvtnorm","devtools","loo","dagitty","shape",
"stan-dev/cmdstanr",
"rmcelreath/rethinking"
))
library(rethinking)
library(ggplot2)
p_grid <- seq(from = 0, to = 1, length.out = 20)
p_grid
prior <- rep(1, 20)
prior
likelihood <- dbinom( 6, size = 9, prob=p_grid)
likelihood
plot( p_grid , likelihood , type="b" ,
xlab="probability of water" , ylab="likelihood" )
mtext( "20 points" )
unstd.posterior <- likelihood * prior
plot( p_grid , unstd.posterior , type="b" ,
xlab="probability of water" , ylab="unstandardized posterior probability" )
mtext( "20 points" )
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior , type="b" ,
xlab="probability of water" , ylab="posterior probability" )
mtext( "20 points" )
globe_posterior <- function(w, n, p_grid, prior) {
likelihood <- dbinom( w, size = n, prob=p_grid)
unstd.posterior <- likelihood * prior
return(posterior <- unstd.posterior / sum(unstd.posterior))
}
prior2 <- ifelse(p_grid < 0.5, 0, 1)
plot(p_grid, prior2, type = "b")
posterior2 <- globe_posterior(6, 9, p_grid, prior2)
plot( p_grid , posterior2 , type="b" ,
xlab="probability of water" , ylab="posterior probability" )
mtext( "20 points" )
prior3 <- exp( -5*abs(p_grid - 0.5))
plot(p_grid, prior3, type = "b")
posterior3 <- globe_posterior(6, 9, p_grid, prior3)
plot( p_grid , posterior3 , type="b" ,
xlab="probability of water" , ylab="posterior probability" )
mtext( "20 points" )
globe.qa <- quap(
alist(
W ~ dbinom( W+L ,p) , # binomial likelihood
p ~ dunif(0,1) # uniform prior
) ,
data=list(W=6,L=3) )
# display summary of quadratic approximation
precis( globe.qa )
globe.qa <- quap(
alist(
W ~ dbinom( W+L ,p) , # binomial likelihood
p ~ dunif(0,1) # uniform prior
) ,
data=list(W=6,L=3) )
# display summary of quadratic approximation
precis( globe.qa )
par(mfrow = c(1,2))
plot( p_grid , posterior , type="b",
xlab="probability of water" , ylab="posterior probability")
mtext( "Grid Approximation (20 points)" )
curve( dnorm(x, 0.67, 0.16), lty=2, xlab="probability of water", ylab="density")
mtext( "Quadratic Approximation" )
curve(dbeta(x, 1, 1), lty=2, xlab="probability of water", ylab="density")
curve(dbeta(x, 1 + 6, 1 + 3), lty = 1, xlab="probability of water", ylab="density")
curve( dnorm(x, 0.67, 0.16), lty=2, add=TRUE)
legend("topleft", legend =c("Exact", "Approximation"), lty = c(1, 2))
# Simulate 100 tosses of the globe where 1 indicates landing on water
# Sum to get the number of tosses that land on water
W <- sum(rbinom(100, 1, .7))
L <- 100 - W
# Use quadratic approximation to estimate the posterior with 100 observations
globe.qa <- quap(
alist(
W ~ dbinom( W+L ,p) , # binomial likelihood
p ~ dunif(0,1) # uniform prior
) ,
data=list(W=W,L=L) )
# display summary of quadratic approximation
precis( globe.qa )
library(ggdag)
dag <- dagify(W ~ H + U, latent = c("U"), coords=time_ordered_coords())
ggdag(dag) + theme_dag()
# R code 3.3
H <- runif(200, min=130, max=170)
W <- sim_weight(H, b=0.5, sd=5)
# R code 3.2
sim_weight <- function(H, b, sd) {
U <- rnorm(length(H), 0, sd)
W <- b*H + U
return(W)
}
# R code 3.3
H <- runif(200, min=130, max=170)
W <- sim_weight(H, b=0.5, sd=5)
plot(W ~ H, col=2, lwd=3)
# Set up a 2x2 plotting area
par(mfrow = c(2, 2))
# Prior for a (intercept)
curve(dnorm(x, 0, 10), from = -30, to = 30,
main = "Prior for a (intercept)",
xlab = "a", ylab = "Density")
# Prior for b (slope)
curve(dunif(x, 0, 1), from = -0.5, to = 1.5,
main = "Prior for b (slope)",
xlab = "b", ylab = "Density")
# Prior for sigma
curve(dunif(x, 0, 10), from = -2, to = 12,
main = "Prior for sigma",
xlab = "sigma", ylab = "Density")
par(mfrow = c(1, 1))  # Reset plotting area
